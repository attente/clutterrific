/*
 * Clutterrific
 * Copyright (C) 2010 William Hua
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */



#define PATCH      64

#define ALBUM       8

#define MIN_WAIT 1000

#define MAX_WAIT 9000

#define MIN_LIFE 3000

#define MAX_LIFE 7000



#include <clutter/clutter.h>

#include "clutterrific.h"



typedef struct
{
  gfloat x[2];

  gfloat y[2];
}
box;



typedef struct
{
  box    b[4];

  gfloat t[2];
}
region;



typedef struct
{
  region        frame;

  gint          layer;

  ClutterActor *actor;

  ClutterColor  colour;
}
swatch;



typedef struct
{
  swatch        frame;

  ClutterActor *photo;

  box           start;

  box           finish;
}
memory;



static gfloat get_width     (const box       *b);

static gfloat get_height    (const box       *b);

static box    interpolate   (const box       *b0,
                             const box       *b1,
                             gfloat           t);

static box    get_frame     (const region    *r,
                             gfloat           t);

static box    get_area      (const memory    *m,
                             gfloat           t);

static box    get_clip      (const memory    *m,
                             gfloat           t);

static void   create_swatch (ClutterTimeline *life,
                             gpointer         patch);

static void   update_swatch (ClutterTimeline *life,
                             gint             time,
                             gpointer         patch);

static void   repeat_swatch (ClutterTimeline *life,
                             gpointer         data);

static void   create_memory (ClutterTimeline *life,
                             gpointer         album);

static void   update_memory (ClutterTimeline *life,
                             gint             time,
                             gpointer         album);

static void   repeat_memory (ClutterTimeline *life,
                             gpointer         data);



static gint         layer;

static ClutterColor old_colour;

static ClutterColor new_colour;

static swatch       patch[PATCH];

static memory       album[ALBUM];



static box
interpolate (const box *b0,
             const box *b1,
             gfloat     t)
{
  box b;

  b.x[0] = b0->x[0] + t * (b1->x[0] - b0->x[0]);
  b.y[0] = b0->y[0] + t * (b1->y[0] - b0->y[0]);
  b.x[1] = b0->x[1] + t * (b1->x[1] - b0->x[1]);
  b.y[1] = b0->y[1] + t * (b1->y[1] - b0->y[1]);

  return b;
}



static box
get_frame (const region *r,
           gfloat        t)
{
  const box *end[2];

  if (t < r->t[0])
  {
    end[0] = r->b + 0;
    end[1] = r->b + 1;

    t /= r->t[0];
  }
  else if (t < r->t[1])
  {
    end[0] = r->b + 1;
    end[1] = r->b + 2;

    t = (t - r->t[0]) / (r->t[1] - r->t[0]);
  }
  else
  {
    end[0] = r->b + 2;
    end[1] = r->b + 3;

    t = (t - r->t[1]) / (1 - r->t[1]);
  }

  return interpolate (end[0], end[1], t);
}



static box
get_area (const memory *m,
          gfloat        t)
{
  return interpolate (&m->start, &m->finish, t);
}



static box
get_clip (const memory *m,
          gfloat        t)
{
  box frame = get_frame (&m->frame.frame, t);
  box area  = get_area  (m, t);
  box clip;

  clip.x[0] = (frame.x[0] - area.x[0]) / get_width  (&area);
  clip.y[0] = (frame.y[0] - area.y[0]) / get_height (&area);
  clip.x[1] = (frame.x[1] - area.x[0]) / get_width  (&area);
  clip.y[1] = (frame.y[1] - area.y[0]) / get_height (&area);

  return clip;
}



static void
create_swatch (ClutterTimeline *life,
               gpointer         patch)
{
  swatch *object = patch;

  if (g_random_boolean ())
  {
    gfloat top = g_random_double_range ();
    gfloat
  }
  else
  {
  }
}



static void
update_swatch (ClutterTimeline *life,
               gint             time,
               gpointer         patch)
{
}



static void
repeat_swatch (ClutterTimeline *life,
               gpointer         data)
{
  g_object_unref (life);

  life = clutter_timeline_new (g_random_int_range (MIN_LIFE, MAX_LIFE + 1));

  clutter_timeline_set_delay (life, g_random_int_range (MIN_WAIT, MAX_WAIT + 1));

  g_signal_connect       (life, "started",   G_CALLBACK (create_swatch), data);
  g_signal_connect       (life, "new-frame", G_CALLBACK (update_swatch), data);
  g_signal_connect_after (life, "completed", G_CALLBACK (repeat_swatch), data);

  clutter_timeline_start (life);
}



static void
create_memory (ClutterTimeline *life,
               gpointer         album)
{
}



static void
update_memory (ClutterTimeline *life,
               gint             time,
               gpointer         album)
{
}



static void
repeat_memory (ClutterTimeline *life,
               gpointer         data)
{
  g_object_unref (life);

  life = clutter_timeline_new (g_random_int_range (MIN_LIFE, MAX_LIFE + 1));

  clutter_timeline_set_delay (life, g_random_int_range (MIN_WAIT, MAX_WAIT + 1));

  g_signal_connect       (life, "started",   G_CALLBACK (create_memory), data);
  g_signal_connect       (life, "new-frame", G_CALLBACK (update_memory), data);
  g_signal_connect_after (life, "completed", G_CALLBACK (repeat_memory), data);

  clutter_timeline_start (life);
}



int
main (int   argc,
      char *argv[])
{
  clutter_init      (&argc, &argv);
  clutterrific_init (&argc, &argv);

  {
    ClutterColor  bg    = { 0, 0, 0, 255 };
    ClutterStage *stage = clutter_stage_get_default ();

    clutter_stage_set_color (CLUTTER_STAGE (stage), &bg);
    clutter_actor_show_all  (stage);
    clutter_actor_get_size  (stage, &width, &height);
  }

  {
    gint i;

    for (i = 0; i < PATCH; i++)
    {
      ClutterTimeline *life = clutter_timeline_new (g_random_int_range (MIN_LIFE, MAX_LIFE + 1));

      clutter_timeline_set_delay (life, g_random_int_range (MIN_WAIT, MAX_WAIT + 1));

      g_signal_connect       (life, "started",   G_CALLBACK (create_swatch), patch + i);
      g_signal_connect       (life, "new-frame", G_CALLBACK (update_swatch), patch + i);
      g_signal_connect_after (life, "completed", G_CALLBACK (repeat_swatch), patch + i);

      clutter_timeline_start (life);
    }

    for (i = 0; i < ALBUM; i++)
    {
      ClutterTimeline *life = clutter_timeline_new (g_random_int_range (MIN_LIFE, MAX_LIFE + 1));

      clutter_timeline_set_delay (life, g_random_int_range (MIN_WAIT, MAX_WAIT + 1));

      g_signal_connect       (life, "started",   G_CALLBACK (create_memory), album + i);
      g_signal_connect       (life, "new-frame", G_CALLBACK (update_memory), album + i);
      g_signal_connect_after (life, "completed", G_CALLBACK (repeat_memory), album + i);

      clutter_timeline_start (life);
    }
  }

  clutter_main ();

  return 0;
}
